#include "threadpool.h"
#define MAX_FD 65535
#define MAX_EVENT_NUMBER 1000

extern "C"
{
    #include "httpd.h"
}

extern "C"
{
    int deal_accept_request(int );
    void print_log(const char* error, int level);
}


class conn
{
public:
    conn(int fd = -1)
        :connfd(fd)
    {}

    ~conn()
    {}

    void process()
    {
        deal_accept_request(connfd);
    }
private:
    int connfd;
};


static void Useage(const char* str)
{
	printf("Usage: %s [local_ip] [local_port]\n",str);
}

int main(int argc, char* argv[])
{
	if(argc != 3)
	{
		Useage(argv[0]);
		return 0;
	}

	//daemon(1,0);
	
	int listensock = startup(argv[1],atoi(argv[2]));
    
    threadpool< conn >* pool = NULL;
    try
    {
        pool = new threadpool< conn >;
    }
    catch( ... )
    {
        return 1;
    }
    
    epoll_event events[ MAX_EVENT_NUMBER ];
    int epollfd = epoll_create(5);
    assert(epollfd != -1);
    addfd(epollfd, listensock);
    
    conn* user = new conn[MAX_FD];
    assert( user != NULL );
    int user_count = 0;

    while(1)
    {
        int number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);
        if(number < 0)
        {
            break;
        }

        for(int i = 0; i < number; ++i)
        {
            int sockfd = events[i].data.fd;
            if(sockfd == listensock)
            {
                struct sockaddr_in client_address;
                socklen_t client_addlenth = sizeof(client_address);
                int connfd = accept(listensock, (struct sockaddr*)&client_address, &client_addlenth);

                if (connfd < 0)
                {
                    continue;
                }
                
                user_count++;
                if(user_count > MAX_FD)
                {
                    printf("user over");
                    user_count--;
                    continue;
                }
                
                addfd(epollfd, connfd);
                conn t(connfd) ;
                user[connfd] = t;
            }
            else if(events[i].events & EPOLLIN)
            {
                pool->append(&user[events[i].data.fd]);
               //user[events[i].data.fd] = -1;
                //close(events[i].data.fd);
            }
            else
            {
                continue;
            }
        }
    }
    
    close(epollfd);
    close(listensock);
    delete [] user;
    delete pool;
	return 0;
}
